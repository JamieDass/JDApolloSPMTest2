"""A date represented as a timestamp"""
scalar Date

"""Flexible JSON data"""
scalar JSON

type User {
  id: ID!
  email: String
  type: UserTypes!
  userName: String
  createdAt: Date!
  updatedAt: Date!
  documents: [Document!]!
}

enum UserTypes {
  ANONYMOUS
  STANDARD
}

enum OrderDirections {
  ASC
  DESC
}

enum OrderTypes {
  updatedAt
  createdAt
}

enum XFDFTypes {
  RAW
  COMMAND_ADD
  COMMAND_MODIFY
  COMMAND_ALL
}

interface Member {
  id: ID!
  documentId: ID!
  lastRead: Date!
}

type AnnotationMember implements Member {
  id: ID!
  documentId: ID!
  annotationId: ID!
  lastRead: Date!
  createdAt: Date!
  updatedAt: Date!
  annotationCreatedAt: Date!
}

type DocumentMember implements Member {
  id: ID!
  user: User!
  documentId: ID!
  lastRead: Date!
  createdAt: Date!
  updatedAt: Date!
}

type Annotation {
  id: ID!
  xfdf: String!
  annotContents: String
  author: User
  annotationId: ID!
  documentId: ID!
  pageNumber: Int!
  createdAt: Date!
  updatedAt: Date!
  membership: AnnotationMember
  mentions: [Mention!]!
  inReplyTo: ID
}

type Document {
  id: ID!
  annotations: [Annotation!]!
  members: [DocumentMember!]!
  author: User!
  createdAt: Date!
  updatedAt: Date!
  isPublic: Boolean
  name: String
  unreadCount: Int!
}

type DeleteResult {
  id: ID
  successful: Boolean!
  message: String
}

type ContextResult {
  token: String!
}

type ConnectResult {
  userId: ID
  documentId: ID
  successful: Boolean!
}

type RestoreSnapshotResult {
  id: ID
  successful: Boolean!
  message: String
  annotations: [Annotation]
}

type Mention {
  id: ID!
  annotationId: ID!
  documentId: ID!
  mentionedUser: User!
  createdAt: Date!
  updatedAt: Date!
}

type Snapshot {
  id: ID!
  author: User
  documentId: ID!
  xfdf: String!
  name: String
  createdAt: Date!
  updatedAt: Date!
}

type SnapshotAsset {
  id: ID!
  snapshotId: ID!
  data: String!
  createdAt: Date!
  updatedAt: Date!
}

type ScrollSyncPosition {
  scrollTop: Int
  scrollHeight: Int
}

input ScrollSyncPositionInput {
  scrollTop: Int
  scrollHeight: Int
}

type ScrollSyncSession {
  leaderId: String!
  documentId: String!
  position: ScrollSyncPosition!
  sessionId: String!
}

input NewSnapshotInput {
  id: ID
  authorId: ID!
  documentId: ID!
  name: String!
  createdAt: Date!
  updatedAt: Date!
}

input EditSnapshotInput {
  name: String
  updatedAt: Date!
}

input RestoreSnapshotInput {
  id: ID!
  name: String!
  createdAt: Date!
}

input NewSnapshotAssetInput {
  id: ID
  snapshotId: ID
  data: String!
  createdAt: Date!
  updatedAt: Date!
}

input EditSnapshotAssetInput {
  snapshotId: ID
  updatedAt: Date!
}

input NewAnnotationInput {
  id: ID
  xfdf: String!
  annotContents: String
  mentionedUserIds: [ID!]
  authorId: ID
  annotationId: ID!
  documentId: ID
  pageNumber: Int!
  inReplyTo: ID
  createdAt: Date!
  updatedAt: Date!
}

input EditAnnotationInput {
  xfdf: String
  annotContents: String
  pageNumber: Int
  mentionedUserIds: [ID!]
  updatedAt: Date!
}

input NewAnnotationMemberInput {
  annotationId: ID!
  documentId: ID!
  userId: ID!
  updatedAt: Date!
  createdAt: Date!
}

input EditAnnotationMemberInput {
  lastRead: Date
  updatedAt: Date!
}

input NewDocumentMemberInput {
  documentId: ID!
  userId: ID!
  lastRead: Date!
  updatedAt: Date!
  createdAt: Date!
}

input EditDocumentMemberInput {
  lastRead: Date
  updatedAt: Date!
}

input NewDocumentInput {
  id: ID
  name: String
  authorId: ID!
  isPublic: Boolean
  updatedAt: Date!
  createdAt: Date!
}

input EditDocumentInput {
  isPublic: Boolean
  name: String
  updatedAt: Date!
}

input NewUserInput {
  userName: String
  email: String
  type: UserTypes
  updatedAt: Date!
  createdAt: Date!
}

input EditUserInput {
  userName: String
  email: String
  type: UserTypes
  updatedAt: Date!
}

input InvitedUserInput {
  id: ID
  userName: String
  email: String
}

input DeleteAnnotationMemberInput {
  memberId: ID
  annotationId: ID
  userId: ID
}

input DeleteDocumentMemberInput {
  memberId: ID!
}

input NewMentionInput {
  userId: ID!
  annotationId: ID!
  documentId: ID!
  updatedAt: Date!
  createdAt: Date!
}

type ConnectedDocUser {
  userId: ID!
  currentPage: Int
}

input EditConnectedDocUserInput {
  documentId: ID!
  userId: ID!
  currentPage: Int
}

input DeleteConnectedDocUserInput {
  documentId: ID!
  userId: ID!
}

type AuthUser {
  id: ID!
  userName: String
  token: String
}

input QuerySettings {
  xfdfFormat: XFDFTypes
}

type Query {
  user(id: ID!, settings: QuerySettings): User!
  annotation(id: ID!, settings: QuerySettings): Annotation
  annotations(documentId: ID!, settings: QuerySettings): [Annotation!]!
  document(id: ID!, settings: QuerySettings): Document
  documents(userId: ID!, limit: Int!, before: Date, orderBy: OrderTypes, orderDirection: OrderDirections, settings: QuerySettings): [Document!]!
  publicDocuments(limit: Int!, before: Date, orderBy: OrderTypes, orderDirection: OrderDirections, settings: QuerySettings): [Document!]!
  session: AuthUser
  snapshot(id: ID!, settings: QuerySettings): Snapshot
  snapshots(documentId: ID!, limit: Int!, before: Date, orderBy: OrderTypes, orderDirection: OrderDirections, settings: QuerySettings): [Snapshot!]!
  snapshotAsset(id: ID!): SnapshotAsset
  snapshotAssets(snapshotId: ID!): [SnapshotAsset!]!
  mentions(annotationId: ID!): [Mention!]!
  connectedDocUsers(documentId: ID!): [ConnectedDocUser!]!
  getAvailableScrollSyncSessions(documentId: ID!): [ScrollSyncSession!]!
}

type Mutation {
  addAnnotation(input: NewAnnotationInput!, settings: QuerySettings): Annotation!
  editAnnotation(id: ID!, input: EditAnnotationInput!, settings: QuerySettings): Annotation!
  deleteAnnotation(id: ID!): DeleteResult!
  addSnapshot(input: NewSnapshotInput!, settings: QuerySettings): Snapshot!
  editSnapshot(id: ID!, input: EditSnapshotInput!, settings: QuerySettings): Snapshot!
  deleteSnapshot(id: ID!): DeleteResult!
  restoreSnapshot(input: RestoreSnapshotInput!, settings: QuerySettings): RestoreSnapshotResult!
  addSnapshotAsset(input: NewSnapshotAssetInput!): SnapshotAsset!
  editSnapshotAsset(id: ID!, input: EditSnapshotAssetInput!): SnapshotAsset!
  deleteSnapshotAsset(id: ID!): DeleteResult!
  copyAnnotations(fromDocId: ID!, toDocId: ID!): Boolean!
  addAnnotationMember(input: NewAnnotationMemberInput!): AnnotationMember!
  editAnnotationMember(annotationId: ID!, userId: ID!, memberId: ID, input: EditAnnotationMemberInput): AnnotationMember!
  updateAnnotationMemberLastRead(annotationId: ID!, userId: ID!): UpdateAnnotationMemberLastReadPayload!
  deleteAnnotationMember(input: DeleteAnnotationMemberInput!): DeleteResult!
  addDocument(document: NewDocumentInput!, annotations: [NewAnnotationInput!], usersInvited: [InvitedUserInput!], settings: QuerySettings): Document!
  inviteUsersToDocument(id: ID!, usersInvited: [InvitedUserInput!], settings: QuerySettings): Document!
  editDocument(id: ID!, input: EditDocumentInput, settings: QuerySettings): Document!
  deleteDocument(id: ID!): DeleteResult!
  addDocumentMember(input: NewDocumentMemberInput!): DocumentMember!
  editDocumentMember(documentId: ID!, userId: ID!, memberId: ID, input: EditDocumentMemberInput): DocumentMember!
  deleteDocumentMember(input: DeleteDocumentMemberInput!): DeleteResult!
  addUser(input: NewUserInput!, settings: QuerySettings): User!
  login(email: String, password: String, token: String): AuthPayload!
  loginAnonymous(userName: String): AuthPayload!
  addMention(input: NewMentionInput): Mention!
  deleteMention(userId: ID!, annotationId: ID!): DeleteResult!
  markAllAsRead(documentId: ID, settings: QuerySettings): Document!
  createScrollSyncSession(documentId: ID!, position: ScrollSyncPositionInput!): ScrollSyncSession!
  joinScrollSyncSession(sessionId: String!): ScrollSyncSession!
  updateScrollSyncSession(sessionId: String!, position: ScrollSyncPositionInput!): ScrollSyncSession!
  exitScrollSyncSession(sessionId: String!): Boolean!
  connectUserToDocument(documentId: ID!, userId: ID!, pageNumber: Int): ConnectResult!
  editConnectedDocUser(input: EditConnectedDocUserInput!): [ConnectedDocUser]
  deleteConnectedDocUser(input: DeleteConnectedDocUserInput!): DeleteResult!
  encodeContext(context: String!, action: EncodeContextActions!): ContextResult!
}

enum EncodeContextActions {
  SET
  MERGE
}

enum ChangeEventTypes {
  ADD
  EDIT
  DELETE
  INVITE
  MARK_AS_READ
}

type AnnotationSubscriptionEvent {
  annotation: Annotation!
  document: Document
  action: ChangeEventTypes!
}

type DocumentSubscriptionEvent {
  document: Document!
  markedAllAsRead: Boolean
  action: ChangeEventTypes!
  invitedBy: String
}

type MentionSubscriptionEvent {
  mention: Mention!
  action: ChangeEventTypes!
}

type ScrollPositionSubscriptionEvent {
  position: ScrollSyncPosition!
  sessionId: String!
}

type ConnectedDocUsersSubscriptionEvent {
  documentId: ID!
  connectedDocUsers: [ConnectedDocUser!]!
  action: ChangeEventTypes!
}

enum SnapshotChangeEventTypes {
  ADD
  EDIT
  DELETE
  RESTORE
}

enum ScrollSyncChangedEventTypes {
  ADD
  DELETE
}

type SnapshotChangedSubscriptionEvent {
  snapshot: Snapshot!
  action: SnapshotChangeEventTypes!
}

type ScrollSyncSessionChangedEvent {
  session: ScrollSyncSession!
  action: ScrollSyncChangedEventTypes!
}

type Subscription {
  annotationChanged(userId: ID!, settings: QuerySettings): AnnotationSubscriptionEvent!
  documentChanged(userId: ID!, settings: QuerySettings): DocumentSubscriptionEvent!
  mentionChanged(userId: ID!): MentionSubscriptionEvent!
  connectedDocUsersChanged(docId: ID!): ConnectedDocUsersSubscriptionEvent!
  snapshotChanged(docId: ID!, userId: ID!): SnapshotChangedSubscriptionEvent!
  scrollPositionChanged(sessionId: ID!): ScrollPositionSubscriptionEvent!
  scrollSyncSessionUpdated(docId: ID!): ScrollSyncSessionChangedEvent!
}

type AuthPayload {
  user: User
  token: String
}

type IgnoreMembership {
  message: String
  annotationId: ID!
}

type AnnotationNotFound {
  message: String
  annotationId: ID!
}

union UpdateAnnotationMemberLastReadPayload = AnnotationMember | AnnotationNotFound | IgnoreMembership
